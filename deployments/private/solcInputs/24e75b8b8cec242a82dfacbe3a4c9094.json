{
  "language": "Solidity",
  "sources": {
    "contracts/BatchDeposit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.5.11;\npragma experimental ABIEncoderV2;\n\n// external dependencies\nimport './openzeppelin/utils/Address.sol';\nimport './openzeppelin/math/SafeMath.sol';\n\nimport './IDeposit.sol';\n\n/// @notice  Batch ETH2 deposits, uses the official Deposit contract from the ETH\n///          Foundation for each atomic deposit. This contract acts as a for loop.\n///          Each deposit size will be an optimal 32 ETH.\n///\n/// @dev     The batch size has an upper bound due to the block gas limit. Each atomic\n///          deposit costs ~62,000 gas. The current block gas-limit is ~12,400,000 gas.\n///\n/// Author:  Staked Securely, Inc. (https://staked.us/)\ncontract BatchDeposit {\n    using Address for address payable;\n    using SafeMath for uint256;\n\n    /*************** STORAGE VARIABLE DECLARATIONS **************/\n\n    uint256 public constant DEPOSIT_AMOUNT = 32 ether;\n    // currently points at the Zinken Deposit Contract\n    // address public constant DEPOSIT_CONTRACT_ADDRESS = 0x5cA1e00004366Ac85f492887AAab12d0e6418876;    //mainnet\n    address public constant DEPOSIT_CONTRACT_ADDRESS = 0x8A04d14125D0FDCDc742F4A05C051De07232EDa4;      //private\n    IDeposit private constant DEPOSIT_CONTRACT = IDeposit(DEPOSIT_CONTRACT_ADDRESS);\n\n    /*************** EVENT DECLARATIONS **************/\n\n    /// @notice  Signals a refund of sent-in Ether that was extra and not required.\n    ///\n    /// @dev     The refund is sent to the msg.sender.\n    ///\n    /// @param  to - The ETH address receiving the ETH.\n    /// @param  amount - The amount of ETH being refunded.\n    event LogSendDepositLeftover(address to, uint256 amount);\n\n    /////////////////////// FUNCTION DECLARATIONS BEGIN ///////////////////////\n\n    /********************* PUBLIC FUNCTIONS **********************/\n\n    /// @notice  Empty constructor.\n    constructor() public {}\n\n    /// @notice  Fallback function.\n    ///\n    /// @dev     Used to address parties trying to send in Ether with a helpful\n    ///          error message.\n    function() external payable {\n        revert('#BatchDeposit fallback(): Use the `batchDeposit(...)` function to send Ether to this contract.');\n    }\n\n    /// @notice Submit index-matching arrays that form Phase 0 DepositData objects.\n    ///         Will create a deposit transaction per index of the arrays submitted.\n    ///\n    /// @param pubkeys - An array of BLS12-381 public keys.\n    /// @param withdrawal_credentials - An array of commitment to public key for withdrawals.\n    /// @param signatures - An array of BLS12-381 signatures.\n    /// @param deposit_data_roots - An array of the SHA-256 hash of the SSZ-encoded DepositData object.\n    function batchDeposit(\n        bytes[] calldata pubkeys,\n        bytes[] calldata withdrawal_credentials,\n        bytes[] calldata signatures,\n        bytes32[] calldata deposit_data_roots\n    ) external payable {\n        require(\n            pubkeys.length == withdrawal_credentials.length &&\n                pubkeys.length == signatures.length &&\n                pubkeys.length == deposit_data_roots.length,\n            \"#BatchDeposit batchDeposit(): All parameter array's must have the same length.\"\n        );\n        require(pubkeys.length > 0, \"#BatchDeposit batchDeposit(): All parameter array's must have a length greater than zero.\");\n        require(\n            msg.value >= DEPOSIT_AMOUNT.mul(pubkeys.length),\n            '#BatchDeposit batchDeposit(): Ether deposited needs to be at least: 32 * (parameter `pubkeys[]` length).'\n        );\n        uint256 deposited = 0;\n\n        // Loop through DepositData arrays submitting deposits\n        for (uint256 i = 0; i < pubkeys.length; i++) {\n            DEPOSIT_CONTRACT.deposit.value(DEPOSIT_AMOUNT)(pubkeys[i], withdrawal_credentials[i], signatures[i], deposit_data_roots[i]);\n            deposited = deposited.add(DEPOSIT_AMOUNT);\n        }\n        assert(deposited == DEPOSIT_AMOUNT.mul(pubkeys.length));\n        uint256 ethToReturn = msg.value.sub(deposited);\n        if (ethToReturn > 0) {\n            // Emit `LogSendDepositLeftover` log\n            emit LogSendDepositLeftover(msg.sender, ethToReturn);\n\n            // This function doesn't guard against re-entrancy, and we're calling an\n            // untrusted address, but in this situation there is no state, etc. to\n            // take advantage of, so re-entrancy guard is unneccesary gas cost.\n            // This function uses call.value(), and handles return values/failures by\n            // reverting the transaction.\n            (msg.sender).sendValue(ethToReturn);\n        }\n    }\n}\n"
    },
    "contracts/IDeposit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.5.11;\n\n/// @notice  Interface of the official Deposit contract from the ETH\n///          Foundation.\ninterface IDeposit {\n    /// @notice Submit a Phase 0 DepositData object.\n    ///\n    /// @param pubkey - A BLS12-381 public key.\n    /// @param withdrawal_credentials - Commitment to a public key for withdrawals.\n    /// @param signature - A BLS12-381 signature.\n    /// @param deposit_data_root - The SHA-256 hash of the SSZ-encoded DepositData object.\n    ///                            Used as a protection against malformed input.\n    function deposit(\n        bytes calldata pubkey,\n        bytes calldata withdrawal_credentials,\n        bytes calldata signature,\n        bytes32 deposit_data_root\n    ) external payable;\n}\n"
    },
    "contracts/openzeppelin/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.5.11;\n\n/// npm package/version - @openzeppelin/contracts-ethereum-package: 2.5.0\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, 'SafeMath: addition overflow');\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, 'SafeMath: subtraction overflow');\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     *\n     * _Available since v2.4.0._\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, 'SafeMath: multiplication overflow');\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, 'SafeMath: division by zero');\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, 'SafeMath: modulo by zero');\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     *\n     * _Available since v2.4.0._\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/openzeppelin/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity 0.5.11;\n\n/// npm package/version - @openzeppelin/contracts-ethereum-package: 2.5.0\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            codehash := extcodehash(account)\n        }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Converts an `address` into `address payable`. Note that this is\n     * simply a type cast: the actual underlying value is not changed.\n     *\n     * _Available since v2.4.0._\n     */\n    function toPayable(address account) internal pure returns (address payable) {\n        return address(uint160(account));\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     *\n     * _Available since v2.4.0._\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, 'Address: insufficient balance');\n\n        // solhint-disable-next-line avoid-call-value\n        (bool success, ) = recipient.call.value(amount)('');\n        require(success, 'Address: unable to send value, recipient may have reverted');\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}